\begin{Verbatim}[commandchars=\\\{\},codes={\catcode`\$=3\catcode`\^=7\catcode`\_=8}]
\PYG{k}{function} \PYG{n}{converge\PYGZus{}ensemble!}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{::}\PYG{n}{IPM\PYGZus{}Ensemble}\PYG{p}{,} \PYG{n}{instruction}\PYG{o}{::}\PYG{n}{Permute\PYGZus{}Instruct}\PYG{p}{,} \PYG{n}{evidence\PYGZus{}fraction}\PYG{o}{::}\PYG{k+kt}{AbstractFloat}\PYG{o}{=.}\PYG{l+m+mi}{001}\PYG{p}{;} \PYG{n}{max\PYGZus{}iterates}\PYG{o}{=}\PYG{n}{typemax}\PYG{p}{(}\PYG{k+kt}{Int64}\PYG{p}{),} \PYG{n}{backup}\PYG{o}{::}\PYG{k+kt}{Tuple}\PYG{p}{\PYGZob{}}\PYG{k+kt}{Bool}\PYG{p}{,}\PYG{k+kt}{Integer}\PYG{p}{\PYGZcb{}}\PYG{o}{=}\PYG{p}{(}\PYG{k+kc}{false}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{),} \PYG{n}{clean}\PYG{o}{::}\PYG{k+kt}{Tuple}\PYG{p}{\PYGZob{}}\PYG{k+kt}{Bool}\PYG{p}{,}\PYG{k+kt}{Integer}\PYG{p}{,}\PYG{k+kt}{Integer}\PYG{p}{\PYGZcb{}}\PYG{o}{=}\PYG{p}{(}\PYG{k+kc}{false}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{),} \PYG{n}{verbose}\PYG{o}{::}\PYG{k+kt}{Bool}\PYG{o}{=}\PYG{k+kc}{false}\PYG{p}{,} \PYG{n}{progargs}\PYG{o}{...}\PYG{p}{)}
    \PYG{n}{N} \PYG{o}{=} \PYG{n}{length}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{)}
    \PYG{n}{log\PYGZus{}frac}\PYG{o}{=}\PYG{n}{log}\PYG{p}{(}\PYG{n}{evidence\PYGZus{}fraction}\PYG{p}{)}
    
    \PYG{n}{curr\PYGZus{}it}\PYG{o}{=}\PYG{n}{length}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Li}\PYG{p}{)}
    \PYG{n}{curr\PYGZus{}it}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{isfile}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{path}\PYG{o}{*}\PYG{l+s}{\PYGZdq{}/inst\PYGZdq{}}\PYG{p}{)} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{p}{(}\PYG{n}{instruction}\PYG{o}{=}\PYG{n}{deserialize}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{path}\PYG{o}{*}\PYG{l+s}{\PYGZdq{}/inst\PYGZdq{}}\PYG{p}{))} \PYG{c}{\PYGZsh{}resume from backed up instruction if any}

    \PYG{n}{curr\PYGZus{}it}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{isfile}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{path}\PYG{o}{*}\PYG{l+s}{\PYGZdq{}/tuner\PYGZdq{}}\PYG{p}{)} \PYG{o}{?} \PYG{p}{(}\PYG{n}{tuner}\PYG{o}{=}\PYG{n}{deserialize}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{path}\PYG{o}{*}\PYG{l+s}{\PYGZdq{}/tuner\PYGZdq{}}\PYG{p}{))} \PYG{o}{:} \PYG{p}{(}\PYG{n}{tuner} \PYG{o}{=} \PYG{n}{Permute\PYGZus{}Tuner}\PYG{p}{(}\PYG{n}{instruction}\PYG{p}{))} \PYG{c}{\PYGZsh{}restore tuner from saved if any}
    \PYG{n}{wk\PYGZus{}mon} \PYG{o}{=} \PYG{n}{Worker\PYGZus{}Monitor}\PYG{p}{([}\PYG{l+m+mi}{1}\PYG{p}{])}
    \PYG{n}{meter} \PYG{o}{=} \PYG{n}{ProgressNS}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,} \PYG{n}{wk\PYGZus{}mon}\PYG{p}{,} \PYG{n}{tuner}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{n}{log\PYGZus{}frac}\PYG{p}{;} \PYG{n}{start\PYGZus{}it}\PYG{o}{=}\PYG{n}{curr\PYGZus{}it}\PYG{p}{,} \PYG{n}{progargs}\PYG{o}{...}\PYG{p}{)}

    \PYG{k}{while} \PYG{p}{(}\PYG{n}{lps}\PYG{p}{(}\PYG{n}{findmax}\PYG{p}{([}\PYG{n}{model}\PYG{o}{.}\PYG{n}{log\PYGZus{}Li} \PYG{k}{for} \PYG{n}{model} \PYG{k+kp}{in} \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{])[}\PYG{l+m+mi}{1}\PYG{p}{],}  \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Xi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{])} \PYG{o}{\PYGZgt{}=} \PYG{n}{lps}\PYG{p}{(}\PYG{n}{log\PYGZus{}frac}\PYG{p}{,}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Zi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{]))} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{p}{(}\PYG{n}{curr\PYGZus{}it} \PYG{o}{\PYGZlt{}=} \PYG{n}{max\PYGZus{}iterates}\PYG{p}{)}
        \PYG{n}{warn}\PYG{p}{,}\PYG{n}{step\PYGZus{}report} \PYG{o}{=} \PYG{n}{nested\PYGZus{}step!}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,} \PYG{n}{instruction}\PYG{p}{)} \PYG{c}{\PYGZsh{}step the ensemble}
        \PYG{n}{warn} \PYG{o}{==} \PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{c}{\PYGZsh{}\PYGZdq{}1\PYGZdq{} passed for warn code means no workers persist; all have hit the permute limit}
                \PYG{p}{(}\PYG{n+nd}{@error} \PYG{l+s}{\PYGZdq{}Failed to find new models, aborting at current iterate.\PYGZdq{}}\PYG{p}{;} \PYG{k}{return} \PYG{n+nb}{e}\PYG{p}{)} \PYG{c}{\PYGZsh{}if there is a warning, iust return the ensemble and print info}
        \PYG{n}{curr\PYGZus{}it} \PYG{o}{+=} \PYG{l+m+mi}{1}

        \PYG{n}{tune\PYGZus{}weights!}\PYG{p}{(}\PYG{n}{tuner}\PYG{p}{,} \PYG{n}{step\PYGZus{}report}\PYG{p}{)}
        \PYG{n}{instruction} \PYG{o}{=} \PYG{n}{tune\PYGZus{}instruction}\PYG{p}{(}\PYG{n}{tuner}\PYG{p}{,} \PYG{n}{instruction}\PYG{p}{)}

        \PYG{n}{backup}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{curr\PYGZus{}it}\PYG{o}{\PYGZpc{}}\PYG{n}{backup}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{e\PYGZus{}backup}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,}\PYG{n}{instruction}\PYG{p}{,}\PYG{n}{tuner}\PYG{p}{)} \PYG{c}{\PYGZsh{}every backup interval, serialise the ensemble and instruction}
        \PYG{n}{clean}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZam{}\PYGZam{}}  \PYG{o}{!}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{sample\PYGZus{}posterior} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{curr\PYGZus{}it}\PYG{o}{\PYGZpc{}}\PYG{n}{clean}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{clean\PYGZus{}ensemble\PYGZus{}dir}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,}\PYG{n}{clean}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{])} \PYG{c}{\PYGZsh{}every clean interval, remove old discarded models}

        \PYG{n}{update!}\PYG{p}{(}\PYG{n}{meter}\PYG{p}{,}\PYG{n}{lps}\PYG{p}{(}\PYG{n}{findmax}\PYG{p}{([}\PYG{n}{model}\PYG{o}{.}\PYG{n}{log\PYGZus{}Li} \PYG{k}{for} \PYG{n}{model} \PYG{k+kp}{in} \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{])[}\PYG{l+m+mi}{1}\PYG{p}{],}  \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Xi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{]),}\PYG{n}{lps}\PYG{p}{(}\PYG{n}{log\PYGZus{}frac}\PYG{p}{,}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Zi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{]))}        
    \PYG{k}{end}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{lps}\PYG{p}{(}\PYG{n}{findmax}\PYG{p}{([}\PYG{n}{model}\PYG{o}{.}\PYG{n}{log\PYGZus{}Li} \PYG{k}{for} \PYG{n}{model} \PYG{k+kp}{in} \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{])[}\PYG{l+m+mi}{1}\PYG{p}{],}  \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Xi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{])} \PYG{o}{\PYGZlt{}} \PYG{n}{lps}\PYG{p}{(}\PYG{n}{log\PYGZus{}frac}\PYG{p}{,}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Zi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{]))}
        \PYG{n}{final\PYGZus{}logZ} \PYG{o}{=} \PYG{n}{logaddexp}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Zi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{],} \PYG{p}{(}\PYG{n}{logsumexp}\PYG{p}{([}\PYG{n}{model}\PYG{o}{.}\PYG{n}{log\PYGZus{}Li} \PYG{k}{for} \PYG{n}{model} \PYG{k+kp}{in} \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{])} \PYG{o}{+}  \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Xi}\PYG{p}{[}\PYG{n}{length}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Li}\PYG{p}{)]} \PYG{o}{\PYGZhy{}} \PYG{n}{log}\PYG{p}{(}\PYG{n}{length}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{))))}
        \PYG{n+nd}{@info} \PYG{l+s}{\PYGZdq{}Job done, sampled to convergence. Final logZ }\PYG{l+s+si}{\PYGZdl{}final\PYGZus{}logZ}\PYG{l+s}{\PYGZdq{}}

        \PYG{n}{e\PYGZus{}backup}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,}\PYG{n}{instruction}\PYG{p}{,}\PYG{n}{tuner}\PYG{p}{)}
        \PYG{n}{clean}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{o}{!}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{sample\PYGZus{}posterior} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{clean\PYGZus{}ensemble\PYGZus{}dir}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c}{\PYGZsh{}final clean}
        \PYG{k}{return} \PYG{n}{final\PYGZus{}logZ}
    \PYG{k}{elseif} \PYG{n}{curr\PYGZus{}it}\PYG{o}{==}\PYG{n}{max\PYGZus{}iterates}
        \PYG{n+nd}{@info} \PYG{l+s}{\PYGZdq{}Job done, sampled to maximum iterate }\PYG{l+s+si}{\PYGZdl{}max\PYGZus{}iterates}\PYG{l+s}{. Convergence criterion not obtained.\PYGZdq{}}

        \PYG{n}{e\PYGZus{}backup}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,}\PYG{n}{instruction}\PYG{p}{,}\PYG{n}{tuner}\PYG{p}{)}
        \PYG{n}{clean}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{o}{!}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{sample\PYGZus{}posterior} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{clean\PYGZus{}ensemble\PYGZus{}dir}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c}{\PYGZsh{}final clean}
        \PYG{k}{return} \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Zi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{]}
    \PYG{k}{end}
\PYG{k}{end}

\PYG{k}{function} \PYG{n}{converge\PYGZus{}ensemble!}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{::}\PYG{n}{IPM\PYGZus{}Ensemble}\PYG{p}{,} \PYG{n}{instruction}\PYG{o}{::}\PYG{n}{Permute\PYGZus{}Instruct}\PYG{p}{,} \PYG{n}{wk\PYGZus{}pool}\PYG{o}{::}\PYG{k+kt}{Vector}\PYG{p}{\PYGZob{}}\PYG{k+kt}{Int64}\PYG{p}{\PYGZcb{},} \PYG{n}{evidence\PYGZus{}fraction}\PYG{o}{::}\PYG{k+kt}{AbstractFloat}\PYG{o}{=.}\PYG{l+m+mi}{001}\PYG{p}{;} \PYG{n}{max\PYGZus{}iterates}\PYG{o}{=}\PYG{n}{typemax}\PYG{p}{(}\PYG{k+kt}{Int64}\PYG{p}{),} \PYG{n}{backup}\PYG{o}{::}\PYG{k+kt}{Tuple}\PYG{p}{\PYGZob{}}\PYG{k+kt}{Bool}\PYG{p}{,}\PYG{o}{\PYGZlt{}:}\PYG{k+kt}{Integer}\PYG{p}{\PYGZcb{}}\PYG{o}{=}\PYG{p}{(}\PYG{k+kc}{false}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{),} \PYG{n}{clean}\PYG{o}{::}\PYG{k+kt}{Tuple}\PYG{p}{\PYGZob{}}\PYG{k+kt}{Bool}\PYG{p}{,}\PYG{k+kt}{Integer}\PYG{p}{,}\PYG{k+kt}{Integer}\PYG{p}{\PYGZcb{}}\PYG{o}{=}\PYG{p}{(}\PYG{k+kc}{false}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{),} \PYG{n}{verbose}\PYG{o}{::}\PYG{k+kt}{Bool}\PYG{o}{=}\PYG{k+kc}{false}\PYG{p}{,} \PYG{n}{progargs}\PYG{o}{...}\PYG{p}{)}
    \PYG{n}{N} \PYG{o}{=} \PYG{n}{length}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{)}
    \PYG{n}{log\PYGZus{}frac}\PYG{o}{=}\PYG{n}{log}\PYG{p}{(}\PYG{n}{evidence\PYGZus{}fraction}\PYG{p}{)}
    
    \PYG{n}{model\PYGZus{}chan}\PYG{o}{=} \PYG{n}{RemoteChannel}\PYG{p}{(()}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{k+kt}{Channel}\PYG{p}{\PYGZob{}}\PYG{k+kt}{Tuple}\PYG{p}{\PYGZob{}}\PYG{k+kt}{Union}\PYG{p}{\PYGZob{}}\PYG{n}{ICA\PYGZus{}PWM\PYGZus{}Model}\PYG{p}{,}\PYG{n}{Nothing}\PYG{p}{\PYGZcb{},}\PYG{k+kt}{Integer}\PYG{p}{,} \PYG{k+kt}{AbstractVector}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZlt{}:}\PYG{k+kt}{Tuple}\PYG{p}{\PYGZcb{}\PYGZcb{}\PYGZcb{}(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{length}\PYG{p}{(}\PYG{n}{wk\PYGZus{}pool}\PYG{p}{)))} \PYG{c}{\PYGZsh{}channel to take EM iterates off of}
    \PYG{n}{job\PYGZus{}chan} \PYG{o}{=} \PYG{n}{RemoteChannel}\PYG{p}{(()}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{k+kt}{Channel}\PYG{p}{\PYGZob{}}\PYG{k+kt}{Tuple}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZlt{}:}\PYG{k+kt}{AbstractVector}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZlt{}:}\PYG{n}{Model\PYGZus{}Record}\PYG{p}{\PYGZcb{},} \PYG{k+kt}{Float64}\PYG{p}{,} \PYG{k+kt}{Union}\PYG{p}{\PYGZob{}}\PYG{n}{Permute\PYGZus{}Instruct}\PYG{p}{,}\PYG{n}{Nothing}\PYG{p}{\PYGZcb{}\PYGZcb{}\PYGZcb{}(}\PYG{l+m+mi}{1}\PYG{p}{))}
    \PYG{n}{put!}\PYG{p}{(}\PYG{n}{job\PYGZus{}chan}\PYG{p}{,(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{,} \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{contour}\PYG{p}{,} \PYG{n}{instruction}\PYG{p}{))}

    \PYG{n+nd}{@async} \PYG{n}{sequence\PYGZus{}workers}\PYG{p}{(}\PYG{n}{wk\PYGZus{}pool}\PYG{p}{,} \PYG{n}{permute\PYGZus{}IPM}\PYG{p}{,} \PYG{n+nb}{e}\PYG{p}{,} \PYG{n}{job\PYGZus{}chan}\PYG{p}{,} \PYG{n}{model\PYGZus{}chan}\PYG{p}{)}
    
    \PYG{n}{curr\PYGZus{}it}\PYG{o}{=}\PYG{n}{length}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Li}\PYG{p}{)}
    \PYG{n}{curr\PYGZus{}it}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{isfile}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{path}\PYG{o}{*}\PYG{l+s}{\PYGZdq{}/inst\PYGZdq{}}\PYG{p}{)} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{p}{(}\PYG{n}{instruction}\PYG{o}{=}\PYG{n}{deserialize}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{path}\PYG{o}{*}\PYG{l+s}{\PYGZdq{}/inst\PYGZdq{}}\PYG{p}{))} \PYG{c}{\PYGZsh{}resume from backed up instruction if any}

    \PYG{n}{wk\PYGZus{}mon}\PYG{o}{=}\PYG{n}{Worker\PYGZus{}Monitor}\PYG{p}{(}\PYG{n}{wk\PYGZus{}pool}\PYG{p}{)}
    \PYG{n}{curr\PYGZus{}it}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{isfile}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{path}\PYG{o}{*}\PYG{l+s}{\PYGZdq{}/tuner\PYGZdq{}}\PYG{p}{)} \PYG{o}{?} \PYG{p}{(}\PYG{n}{tuner}\PYG{o}{=}\PYG{n}{deserialize}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{path}\PYG{o}{*}\PYG{l+s}{\PYGZdq{}/tuner\PYGZdq{}}\PYG{p}{))} \PYG{o}{:} \PYG{p}{(}\PYG{n}{tuner} \PYG{o}{=} \PYG{n}{Permute\PYGZus{}Tuner}\PYG{p}{(}\PYG{n}{instruction}\PYG{p}{))} \PYG{c}{\PYGZsh{}restore tuner from saved if any}
    \PYG{n}{meter} \PYG{o}{=} \PYG{n}{ProgressNS}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,} \PYG{n}{wk\PYGZus{}mon}\PYG{p}{,} \PYG{n}{tuner}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{n}{log\PYGZus{}frac}\PYG{p}{;} \PYG{n}{start\PYGZus{}it}\PYG{o}{=}\PYG{n}{curr\PYGZus{}it}\PYG{p}{,} \PYG{n}{progargs}\PYG{o}{...}\PYG{p}{)}

    \PYG{c}{\PYGZsh{}while lps(findmax([model.log\PYGZus{}Li for model in e.models])[1],  e.log\PYGZus{}Xi[end]) \PYGZgt{}= lps(log\PYGZus{}frac,e.log\PYGZus{}Zi[end])}
    \PYG{k}{while} \PYG{p}{(}\PYG{n}{lps}\PYG{p}{(}\PYG{n}{findmax}\PYG{p}{([}\PYG{n}{model}\PYG{o}{.}\PYG{n}{log\PYGZus{}Li} \PYG{k}{for} \PYG{n}{model} \PYG{k+kp}{in} \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{])[}\PYG{l+m+mi}{1}\PYG{p}{],}  \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Xi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{])} \PYG{o}{\PYGZgt{}=} \PYG{n}{lps}\PYG{p}{(}\PYG{n}{log\PYGZus{}frac}\PYG{p}{,}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Zi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{]))} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{p}{(}\PYG{n}{curr\PYGZus{}it} \PYG{o}{\PYGZlt{}=} \PYG{n}{max\PYGZus{}iterates}\PYG{p}{)}

        \PYG{c}{\PYGZsh{}REMOVE OLD LEAST LIKELY MODEL \PYGZhy{} perform here to spare all workers the same calculations}
        \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{contour}\PYG{p}{,} \PYG{n}{least\PYGZus{}likely\PYGZus{}idx} \PYG{o}{=} \PYG{n}{findmin}\PYG{p}{([}\PYG{n}{model}\PYG{o}{.}\PYG{n}{log\PYGZus{}Li} \PYG{k}{for} \PYG{n}{model} \PYG{k+kp}{in} \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{])}
        \PYG{n}{Li\PYGZus{}model} \PYG{o}{=} \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{[}\PYG{n}{least\PYGZus{}likely\PYGZus{}idx}\PYG{p}{]}
        \PYG{n}{deleteat!}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{,} \PYG{n}{least\PYGZus{}likely\PYGZus{}idx}\PYG{p}{)}
        \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{sample\PYGZus{}posterior} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{push!}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{retained\PYGZus{}posterior\PYGZus{}samples}\PYG{p}{,} \PYG{n}{Li\PYGZus{}model}\PYG{p}{)}\PYG{c}{\PYGZsh{}if sampling posterior, push the model record to the ensemble\PYGZsq{}s posterior samples vector}

        \PYG{n}{warn}\PYG{p}{,} \PYG{n}{step\PYGZus{}report} \PYG{o}{=} \PYG{n}{nested\PYGZus{}step!}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,} \PYG{n}{model\PYGZus{}chan}\PYG{p}{,} \PYG{n}{wk\PYGZus{}mon}\PYG{p}{,} \PYG{n}{Li\PYGZus{}model}\PYG{p}{)} \PYG{c}{\PYGZsh{}step the ensemble}
        \PYG{n}{warn} \PYG{o}{==} \PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{c}{\PYGZsh{}\PYGZdq{}1\PYGZdq{} passed for warn code means no workers persist; all have hit the permute limit}
                \PYG{p}{(}\PYG{n+nd}{@error} \PYG{l+s}{\PYGZdq{}All workers failed to find new models, aborting at current iterate.\PYGZdq{}}\PYG{p}{;} \PYG{k}{return} \PYG{n+nb}{e}\PYG{p}{)} \PYG{c}{\PYGZsh{}if there is a warning, iust return the ensemble and print info}
        \PYG{n}{curr\PYGZus{}it} \PYG{o}{+=} \PYG{l+m+mi}{1}
        \PYG{n}{tune\PYGZus{}weights!}\PYG{p}{(}\PYG{n}{tuner}\PYG{p}{,} \PYG{n}{step\PYGZus{}report}\PYG{p}{)}
        \PYG{n}{instruction} \PYG{o}{=} \PYG{n}{tune\PYGZus{}instruction}\PYG{p}{(}\PYG{n}{tuner}\PYG{p}{,} \PYG{n}{instruction}\PYG{p}{)} 
        \PYG{n}{take!}\PYG{p}{(}\PYG{n}{job\PYGZus{}chan}\PYG{p}{);} \PYG{n}{put!}\PYG{p}{(}\PYG{n}{job\PYGZus{}chan}\PYG{p}{,(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{,}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{contour}\PYG{p}{,}\PYG{n}{instruction}\PYG{p}{))}
        \PYG{n}{backup}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{curr\PYGZus{}it}\PYG{o}{\PYGZpc{}}\PYG{n}{backup}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{e\PYGZus{}backup}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,}\PYG{n}{instruction}\PYG{p}{,}\PYG{n}{tuner}\PYG{p}{)} \PYG{c}{\PYGZsh{}every backup interval, serialise the ensemble and instruction}
        \PYG{n}{clean}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{o}{!}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{sample\PYGZus{}posterior} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{curr\PYGZus{}it}\PYG{o}{\PYGZpc{}}\PYG{n}{clean}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{clean\PYGZus{}ensemble\PYGZus{}dir}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,}\PYG{n}{clean}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{])} \PYG{c}{\PYGZsh{}every clean interval, remove old discarded models}

        \PYG{n}{update!}\PYG{p}{(}\PYG{n}{meter}\PYG{p}{,} \PYG{n}{lps}\PYG{p}{(}\PYG{n}{findmax}\PYG{p}{([}\PYG{n}{model}\PYG{o}{.}\PYG{n}{log\PYGZus{}Li} \PYG{k}{for} \PYG{n}{model} \PYG{k+kp}{in} \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{])[}\PYG{l+m+mi}{1}\PYG{p}{],} \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Xi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{]),} \PYG{n}{lps}\PYG{p}{(}\PYG{n}{log\PYGZus{}frac}\PYG{p}{,}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Zi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{]))}
    \PYG{k}{end}

    \PYG{n}{take!}\PYG{p}{(}\PYG{n}{job\PYGZus{}chan}\PYG{p}{);} \PYG{n}{put!}\PYG{p}{(}\PYG{n}{job\PYGZus{}chan}\PYG{p}{,} \PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{,} \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{contour}\PYG{p}{,} \PYG{n+nb}{nothing}\PYG{p}{))} \PYG{c}{\PYGZsh{}nothing instruction terminates worker functions}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{lps}\PYG{p}{(}\PYG{n}{findmax}\PYG{p}{([}\PYG{n}{model}\PYG{o}{.}\PYG{n}{log\PYGZus{}Li} \PYG{k}{for} \PYG{n}{model} \PYG{k+kp}{in} \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{])[}\PYG{l+m+mi}{1}\PYG{p}{],}  \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Xi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{])} \PYG{o}{\PYGZlt{}} \PYG{n}{lps}\PYG{p}{(}\PYG{n}{log\PYGZus{}frac}\PYG{p}{,}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Zi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{]))}
        \PYG{n}{final\PYGZus{}logZ} \PYG{o}{=} \PYG{n}{logaddexp}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Zi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{],} \PYG{p}{(}\PYG{n}{logsumexp}\PYG{p}{([}\PYG{n}{model}\PYG{o}{.}\PYG{n}{log\PYGZus{}Li} \PYG{k}{for} \PYG{n}{model} \PYG{k+kp}{in} \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{])} \PYG{o}{+}  \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Xi}\PYG{p}{[}\PYG{n}{length}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Li}\PYG{p}{)]} \PYG{o}{\PYGZhy{}} \PYG{n}{log}\PYG{p}{(}\PYG{n}{length}\PYG{p}{(}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{models}\PYG{p}{))))}
        \PYG{n+nd}{@info} \PYG{l+s}{\PYGZdq{}Job done, sampled to convergence. Final logZ }\PYG{l+s+si}{\PYGZdl{}final\PYGZus{}logZ}\PYG{l+s}{\PYGZdq{}}

        \PYG{n}{e\PYGZus{}backup}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,}\PYG{n}{instruction}\PYG{p}{,}\PYG{n}{tuner}\PYG{p}{)}
        \PYG{n}{clean}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{o}{!}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{sample\PYGZus{}posterior} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{clean\PYGZus{}ensemble\PYGZus{}dir}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c}{\PYGZsh{}final clean}
        \PYG{k}{return} \PYG{n}{final\PYGZus{}logZ}
    \PYG{k}{elseif} \PYG{n}{curr\PYGZus{}it}\PYG{o}{==}\PYG{n}{max\PYGZus{}iterates}
        \PYG{n+nd}{@info} \PYG{l+s}{\PYGZdq{}Job done, sampled to maximum iterate }\PYG{l+s+si}{\PYGZdl{}max\PYGZus{}iterates}\PYG{l+s}{. Convergence criterion not obtained.\PYGZdq{}}

        \PYG{n}{e\PYGZus{}backup}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,}\PYG{n}{instruction}\PYG{p}{,}\PYG{n}{tuner}\PYG{p}{)}
        \PYG{n}{clean}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{o}{!}\PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{sample\PYGZus{}posterior} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{clean\PYGZus{}ensemble\PYGZus{}dir}\PYG{p}{(}\PYG{n+nb}{e}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c}{\PYGZsh{}final clean}
        \PYG{k}{return} \PYG{n+nb}{e}\PYG{o}{.}\PYG{n}{log\PYGZus{}Zi}\PYG{p}{[}\PYG{k}{end}\PYG{p}{]}
    \PYG{k}{end}
\PYG{k}{end}
\end{Verbatim}
